---
title: "Malware Analysis with FCA"
subtitle: Supplementary material for the paper ``A Formal Concept Analysis Approach to Hierarchical Description of Malware Threats"
author: 
  - Manuel Ojeda-Hernández 
  - Domingo López-Rodríguez
  - Ángel Mora
format: 
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    keep-tex: true
    include-in-header: 
      - text: |
          \allowdisplaybreaks
          \usepackage{setspace}
          \newcommand\mybox[2]{\parbox[t]{#1}{\setstretch{1}\raggedright#2}}
---

\thispagestyle{empty}

# Introduction

This document accompanies the paper **A Formal Concept Analysis Approach to Hierarchical Description of Malware Threats**. It is intended to give a more detailed view on the processing done in the main manuscript to infer the hierarchical relations among different malware threats.

We interleave explanations with sample code to enhance the replicability of the results. This document and the required code are stored in the GitHub repository [`Malaga-FCA-group/VirusTotal-Malware-Hierarchy`](https://github.com/Malaga-FCA-group/VirusTotal-Malware-Hierarchy).

# Setup

Let us prepare the environment to perform the study. We will need R and RStudio. In the following subsections, we describe which packages and auxiliar functions are needed.

## Packages needed

Let us load the required packages to perform all the processing:

```{r setup_pkg}
#| warning: false
#| message: false
library(jsonlite)    # <1>
library(tidyjson)    # <1>
library(tidyverse)   # <2>
library(data.table)  # <3>
```
1. Needed to operate with JSON files.
2. Needed for cleaning up the data.
3. Needed to manage tabular data.

We will also need the `fcaR` library to perform the operations with FCA tools. Please, install the latest development version from GitHub:

```{r install_fcaR}
#| eval: false
# Note: the remotes package is needed.
remotes::install_github("neuroimaginador/fcaR")
```

Then, we can load the library functions by doing:

```{r load_fcaR}
#| warning: false
#| message: false
library(fcaR)
```

## Auxiliary functions

We have some accompanying auxiliar functions for particular steps in the processing.

```{r aux_fun}
#| warning: false
#| message: false
source("parse_results.R")
source("names_cleanup.R")
source("transform_name_pattern.R")
```


# Data availability

Data for this study has been provided by VirusTotal as a set of JSON files containing information about scanned files: permissions and activities detected in the file, and the result of scanning the suspicious file with more than 70 antiviruses.

For more details on accessing the reports generated for single files, you can visit \url{https://developers.virustotal.com/reference/overview}.

For demosntration purposes, we will use the dataset provided by VirusTotal, whose JSON files are located in the "Android" folder beneath the current folder (where this files resides).

```{r threat_files}
#| warning: false
#| message: false
folder <- here::here("Android") # <1>

# List of JSON files
files <- list.files(path = folder,       # <2>
                    pattern = "json$",
                    full.names = TRUE)
```
1. `folder` points to the "Android" subfolder.
2. Returns a list of all the files in that folder whose extension is `json`.

# Data preprocessing

Let us begin with an example of the relevant parts of a JSON file. We will use this example throughout this document to show the process performed on the data.

\begin{verbatim}
```{r json_file}
#| results: asis
#| echo: false
#| warning: false
#| message: false
file <- files[1]
json_data <- fromJSON(file)
json_data$scans[c("Bkav", "Lionic", "Symantec")] |> 
  toJSON(pretty = TRUE)
```
\end{verbatim}


**Detection table**

Note that we are interested in having a table with what each antivirus has detected, for each file. For the sample JSON above, it would look like the following:

```{r sample_table}
#| echo: false
#| warning: false
#| message: false
#| results: asis
#| layout-align: center
table <- matrix(
  c("Bkav", "Lionic", "Symantec", "$\\vdots$",
    json_data$scans[c("Bkav", "Lionic", "Symantec")] |> sapply(\(x) {x <- x$result; x[is.null(x)] <- NA; x} ) |> unlist(), "$\\vdots$"),
  ncol = 2, nrow = 4)

colnames(table) <- c("Engine", "Result")

table |> 
  knitr::kable(format = "latex", escape = FALSE,
               booktabs = TRUE,
               align = "ll")
```

This can be achieved (for all the files at once) with the following code:

```{r read_files}
#| message: false
#| warning: false
results <- files |> 
  lapply(\(f) jsonlite::fromJSON(f)$scans |>      # <1>
           parse_results()) |>                    # <2>
  purrr::reduce(dplyr::full_join, by = "engine")  # <3>
```
1. Import each file and access to the `scans` field.
2. For each one, we parse the results, giving two columns, one with the name of the engines and the other with the result of the detection: `NA` means no detection; otherwise, the name of the detected threat.
3. Make a full join of all the tables.

Now, we have a table with:

- One row for each antivirus used in the detections.
- One column called `engine` that stores the names of the antiviruses.
- One column per scanned file.

We want to tidy this table up:

1. Mark the NAs with the character string ``NA".
2. Store the antivirus names in a variable to use it later.
3. Remove the `engine` column as it is redundant.
4. Transpose the table to have files as rows. 
5. Add as row names the names of the scanned files and as column names the engines used.
These two points are needed by FCA, since our attributes are the set of tags given by the different engines, and must be in columns. 

These five items are implemented in the following code:

```{r transform}
#| warning: false
#| message: false
results[is.na(results)] <- "NA"          # <1>  
used_engines <- results$engine           # <2>
results$engine <- NULL                   # <3>
results <- data.table::transpose(results)# <4>
rownames(results) <- basename(files)     # <5>
colnames(results) <- used_engines
```

Up to this moment, we have obtained a matrix as in the following example:

```{r sample_matrix}
#| echo: false
#| warning: false
#| message: false
#| results: asis
#| layout-align: center
table <- matrix(
  c(json_data$scans[c("Bkav", "Lionic", "Symantec")] |> sapply(\(x) {x <- x$result; x[is.null(x)] <- NA; x} ) |> unlist(), "$\\cdots$", "$\\vdots$", "$\\vdots$", "$\\vdots$", "$\\vdots$"),
  ncol = 4, nrow = 2, byrow = TRUE)

colnames(table) <- c("Bkav", "Lionic", "Symantec", "$\\cdots$")
rownames(table) <- c("file00001", "$\\vdots$")

table |> 
  knitr::kable(format = "latex", escape = FALSE,
               booktabs = TRUE,
               align = "llll", row.names = TRUE)
```

# Computations with FCA tools

Now, we present the transformations made in this dataset in order to have it processed using FCA tools. For the sake of simplicity, we will constraint the dataset to a subset of the engines used:

```{r filter_engines}
my_engines <- c("Avast-Mobile", "Avira", "ESET-NOD32", "Kaspersky", "McAfee",
"Microsoft")

results <- results[, colnames(results) %in% my_engines]
```

Doing so, we can obtain interesting results with less computaitonal effort, so this notebook can be executed more easily in any computer.

Now, let us build a formal context from the above table. Since the values of each attribute are nominal (the tags given by the corresponding antivirus), we must perform a scaling on the context to obtain a binary table.

Let us explain what a nominal scaling is. Suppose that we have the following column in our table:

```{r sample_nominal_scaling}
#| echo: false
#| warning: false
#| message: false
#| results: asis
I <- matrix(c("tag1", "tag2", "NA", "tag1", "tag3"), ncol = 1)
colnames(I) <- "av"
rownames(I) <- c("file1", "file2", "file3", "file4", "file5")

fcI <- FormalContext$new(I)
I |> knitr::kable(row.names = TRUE, col.names = "av")
```

Here, we only represent one column (`av`) since scalings in FCA are performed on attributes in an independent manner, that is, each attribute is processed independently of the others, even maybe with a different type of scaling.

Since we need to have a binary data table, we use the following transformation rule, that details how to encode each value in that column with binary representation:

```{r sample_nominal_scaling2}
#| echo: false
#| warning: false
#| message: false
#| results: asis
fcI$scale("av", "nominal")
#fcI$get_scales("av")$to_latex()
```

\begin{center}
\begin{tabular}{r|cccc}
  & av = NA & av = tag1 & av = tag2 & av = tag3\\ 
 \hline 
 NA & $\times$ &  &  &  \\
tag1 &  & $\times$ &  &  \\
tag2 &  &  & $\times$ &  \\
tag3 &  &  &  & $\times$ 
\end{tabular}
\end{center}

In this case, the nominal scaling coincides with what is termed "one-shot encoding" in other Machine Learning fields. This transformation leads us to a binary formal context:

```{r sample_nominal_scaling3}
#| echo: false
#| warning: false
#| message: false
#| results: asis
#fcI$to_latex()
```

\begin{center}
\begin{tabular}{r|cccc}
  & av = NA & av = tag1 & av = tag2 & av = tag3\\ 
 \hline 
file1 &  & $\times$ &  &  \\
file2 &  &  & $\times$ &  \\
file3 & $\times$ &  &  &  \\
file4 &  & $\times$ &  &  \\
file5 &  &  &  & $\times$ 
\end{tabular}
\end{center}

With `fcaR`, this process is handled automatically by doing:

```{r fc}
#| warning: false
#| message: false
# Formal context with all the objects and attributes
fc <- FormalContext$new(results)

# Nominal scaling: each column is transformed into n columns, 
# each one with a binary value.
fc$scale(attributes = fc$attributes,
         type = "nominal")
```

This produces a context with `r length(fc$objects)` objects (scanned files) and `r length(fc$attributes)` attributes (pairs ``antivirus = tag"). Let us show the first attributes:

```{r first_attributes}
#| echo: false
#| warning: false
#| message: false
#| results: asis
glue::glue('`{fc$attributes[1:10]}`') |> 
  stringr::str_flatten_comma(last = " and ") |> 
  cat()
```
The meaning of attribute `Symantec = PUA.Gen.2` is as follows: if it is marked as present for a given file, then the antivirus Symantec had detected the `PUA.Gen.2` malware in that file. As a particular case, if the attribute `Symantec = NA` is marked for a file, this means that Symantec did not detect any malware in that file.

We will perform a transformation in these names to get them as in the paper, that, we want to transform the patterns `antivirus = tag` into $\langle\text{antivirus}, \text{tag}\rangle$ and `antivirus = NA` into $\langle\text{antivirus}, \varnothing\rangle$.

```{r transform_name_pattern}
fc$attributes <- transform_name_pattern(fc$attributes)
```

This command has transformed the previous list of attributes to:

```{r first_attributes_new}
#| echo: false
#| warning: false
#| message: false
#| results: asis
glue::glue('{fc$attributes[1:10]}') |> 
  stringr::str_flatten_comma(last = " and ") |> 
  cat()
```

## Identification of equivalent tags

We now perform clarification in the formal context, that helps in determining equivalent attributes, that is, we will say that $\langle\text{antivirus1}, \text{tag1}\rangle \equiv \langle\text{antivirus2}, \text{tag2}\rangle$ if the set of files where antivirus1 detected the malware named tag1 coincides with the set of files where antivirus2 detected the malware tag2.

```{r clarify}
# Group equal columns/rows
fc2 <- fc$clarify(TRUE)
```

The new formal context has `r length(fc2$attributes)` attributes (columns), what means that some of the attributes in the original formal context had equivalences. We will list those equivalences in @sec-equiv. For now, we give an example:

```{r equivalences1}
#| echo: false
#| warning: false
#| message: false
#| results: asis
# Which attributes have been mixed: equivalent attributes:
idx <- fc2$attributes |> 
  stringr::str_detect("\\[")
attr_equiv <- fc2$attributes[idx]

attrib_equiv_latex <- attr_equiv %>%
  sapply(\(str) {

    str2 <- str |> 
      stringr::str_remove_all("(\\[|\\])") |> 
      stringr::str_replace_all("\\$, \\$", "$_,_$") |> 
      stringr::str_split_1("_,_")
    
    n <- length(str2)
    
    my_str <- stringr::str_c(
      "\\mybox{0.26\\textwidth}{",
      str2[1], "} & \\ensuremath{\\equiv} \\mybox{0.7\\textwidth}{",
      str_flatten(
        str2[2:n], 
        collapse = " \\ensuremath{\\equiv} "),
      "}"
    )    
    my_str

  }) %>% unname() |> unlist()

cat("\\begin{longtable*}{ll}\n")
paste0(attrib_equiv_latex[5], "\\\\\n") |> 
  cat()
cat("\n\\end{longtable*}\n")
```
Here, the meaning of this equivalence is that every file that is assigned the tag `!0edb4e42346f` by McAfee has also been assigned the corresponding tags from ESET-NOD32 and Avira. And viceversa, every file assigned to the above ESET-NOD32 or Avira tags is also assigned to  `!0edb4e42346f` by McAfee. This means that these tags determine exactly the same malware (conditioned to the scope of the dataset used).


## Construction of the concept lattice

The concept lattice of the clarified formal context is isomorphic to that of the original formal context, but it is easier to compute due to the reduced number of attributes. Thus, we will compute the concept lattice from this new context.

```{r lattice}
fc2$find_concepts()
```

This lattice consists of `r fc2$concepts$size()` concepts. Let us show it in @fig-lattice.
```{r lattice_plot}
#| echo: false
#| label: fig-lattice
#| fig-cap: Concept lattice of our formal context.
fc2$concepts$plot()
```

### Meaning of concepts

Let us inspect the meaning of a concept in this scenario with an example. The following is a concept of our formal context:

$$(A, B)\quad\text{with}\quad\left\{
\begin{array}{ll}
A = & \{\text{cd581c0251f2b1e7559c4b5830.json}, \\
    & \,\text{fb1bd5c6486f120268c0803901.json}, \\
    & \,\text{44ed7c95e37adfa1e90cc55847.json}\}\\
B = & \{\langle\text{Kaspersky}, \text{not-a-virus:heur:.os.adlo.b}\rangle,\\
  & \langle\text{Avast-Mobile}, \text{:evo-gen}\rangle, \\
  & \langle\text{Avira}, \text{/agent.mer.gen}\rangle, \\
  & \langle\text{Microsoft}, \text{:script/wacatac.b!ml}\rangle\}
\end{array}
\right.$$

$A$ is a set of files (objects in our formal context) and $B$ is a set of tags or identifiers given by different antivirus systems to each file (attributes). The names of the files have been shortened for the sake of readability. The fact that this is a concept means that the common attributes of all the files in $A$ are those in $B$ (there is no other attribute shared by these three files). That is, the identifiers expressed in $B$ are the ones of the malware detected in all these files. There is no other malware identifier in common among these files.

And conversely, the only three files that have been assigned the identifiers given in $B$ are those in $A$. No file outside $A$ has all the identifiers in $B$. 

This explanation, in terms of the problem at hand, is what allow us to talk about malware _families_, _categories_ or _classes_.

### How to use the concept hierarchy to determine subfamily relations between identifiers

The following explanation extends and explains the study done on the hierarchy of malware as presented in the manuscript in Tables 2 and 3.

Let us consider we want to study an identifier of the form $\langle$antivirus, tag$\rangle$:

1. Look for the *attribute concept* corresponding to $\langle$antivirus, tag$\rangle$. Let us call it $C$.
2. Check if $C$ is a coatom:
   a. If it is a coatom, $\langle$antivirus, tag$\rangle$ is a generic tag, it is not a subtype of another tag.
   b. If it is not a coatom:
      i. If it has only one upper neighbour $(A, B)$ then $\langle$antivirus, tag$\rangle$ is strictly contained in the intersection of all the identifiers in $B$.
      ii. If it has more than one upper neighbour, let $\{(A_i, B_i)\}$ be the set of its upper neighbours. Then the identifier $\langle$antivirus, tag$\rangle$ corresponds exactly to the intersection of all the identifiers in $\cup_i B_i$.

The following code, using `fcaR` methods, allows us to compute these hierarchical dependencies:
```{r dependencies}
# Let us build lists of generic types and of subfamilies
contained <- list()
equal <- list()
coatoms <- list()
top <- fc2$concepts$top()
for (name in fc2$attributes) {
  
  # Compute the corresponding attribute concept
  C <- fc2$att_concept(name)
  
  # Check if it is a coatom
  Upper <- fc2$concepts$upper_neighbours(C)
  if (Upper$sub(1) %==% top) {
    
    # If it is, add it to the list of coatoms
    coatoms[[name]] <- C$get_intent()
    
  } else {
    
    # Otherwise, check how many upper neighbours it has
    if (Upper$size() == 1) {
      
      # Only one: properly contained in its parent concept.
      contained[[name]] <- Upper$sub(1)$get_intent()
      
    } else {
      
      # More than one: it is equal to the intersection of the 
      # identifiers in all its parent concepts.
      # Thus, make the union (%|%) of all the intents of the 
      # upper neighbours.
      equal[[name]] <- Upper$to_list() |> 
        lapply(\(x) x$get_intent()) |> 
        purrr::reduce(`%|%`)
      
    }
    
  }
    
}
```

Some of the coatoms (generic tags) are:

```{r generic_tags}
#| echo: false
#| results: asis
coatoms[c(5, 9, 19)] |> 
  lapply(\(x) {v <- x |> as_vector(); names(v)[v > 0]}) |> 
  stringr::str_flatten_comma(last = " and ") |> 
  cat()
```

The whole set of generic tags is listed in @sec-generictags. Let us now inspect subclassses or subfamilies. We have found two kinds of relations between subfamilies:

- A tag coincides with the intersection of another set of tags or identifiers:
$\langle$av0, tag0$\rangle = \langle$av1, tag1$\rangle\cap\langle$av2, tag2$\rangle\cap\ldots$

This expression must be understood as: "Every file whose identifier is tag0 by the antivirus av0, also receives the identifiers tag*i* by every antivirus av*i*. And conversely, if a file is assigned all the tag*i* identifiers by the corresponding av*i*, then it will also have the identifier tag0 given by av0."

For instance:
$\langle$McAfee, !02f9c9bb715b$\rangle = \langle$ESET-NOD32, a variant of /.gzb$\rangle \cap \langle$Kaspersky, not-a-virus:heur:.os.adlo.a$\rangle\cap\langle$Avast-Mobile, $\varnothing$$\rangle\cap\langle$Avira, $\varnothing$$\rangle\cap\langle$Microsoft, :os/multiverze$\rangle$

Every time a file is assigned **all** the identifiers in the right hand side, it will also be assigned `!02f9c9bb715b` from McAfee, and viceversa.

- A tag is properly contained in the intersection of another set of tags or identifiers:
$\langle$av0, tag0$\rangle \subsetneq \langle$av1, tag1$\rangle\cap\langle$av2, tag2$\rangle\cap\ldots$

This expression must be understood as: "Every file whose identifier is tag0 by the antivirus av0, also receives the identifiers tag*i* by every antivirus av*i*. But there are files which are assigned all the tag*i* identifiers by the corresponding av*i*, that **do not have** the identifier tag0 given by av0."

For instance:
$\langle$McAfee, !0c5c3d793761$\rangle$$\subsetneq$
$\langle$ESET-NOD32, a variant of /.hvn$\rangle \cap \langle$Kaspersky, not-a-virus:heur:.os.adlo.b$\rangle \cap \langle$Avast-Mobile, :evo-gen$\rangle \cap \langle$Avira, /agent.mer.gen$\rangle \cap \langle$Microsoft, :script/sabsik.fl.b!ml$\rangle$

With this information, we can confirm that $\langle$McAfee, !0c5c3d793761$\rangle$ is an identifier that conforms a proper subfamily inside the malware classes defined by the identifiers in the right hand side.

In @sec-subfamilies we present the entire set of (proper) subfamilies.

# Result listings

In this section, we will show the relations found using the concept lattice and the clarification of the context.

For the sake of clarity, we use the expression [$\langle$av1, tag1$\rangle$, $\langle$av2, tag2$\rangle$, $\ldots$] to denote that $\langle$av1, tag1$\rangle$, $\langle$av2, tag2$\rangle$, $\ldots$ are all equivalent identifiers.

## Equivalences found {#sec-equiv}

```{r equivalences}
#| echo: false
#| warning: false
#| message: false
#| results: asis
cat("\\begin{longtable*}{ll}\n")
attrib_equiv_latex |> 
  stringr::str_flatten("\\\\\n\\addlinespace\n") |> 
  cat()
cat("\\end{longtable*}\n")
```
<!-- "\\\\[2ex]\\midrule\n" -->


## Generic tags {#sec-generictags}

```{r generic_tags2}
#| echo: false
#| results: asis
my_names <- coatoms |> 
  sapply(\(x) {v <- as_vector(x); names(v)[v > 0]})

my_names <- c(paste0("\\mybox{0.45\\textwidth}{", my_names, "}"), rep("", times = length(my_names) %% 2)) |> 
  matrix(ncol = 2)

generic_tags <- my_names |> 
  apply(1, \(x) paste0(x[1], " & ", x[2])) |> 
  stringr::str_flatten(" \\\\\n\\addlinespace\n")

cat("\\begin{longtable*}{ll}\n")
cat(generic_tags)
cat("\\end{longtable*}\n")
```

## Subfamilies {#sec-subfamilies}

### Tags that coincide with the intersection of parent identifiers

```{r coincide}
#| echo: false
#| warning: false
#| message: false
#| results: asis
first_col <- names(equal)
coinc <- equal |> 
  sapply(\(x) {v <- x |> as_vector(); names(v)[v > 0] |> stringr::str_flatten(" $\\cap$ ")})
coincides <- sapply(seq_along(equal), \(i) {
  
  glue::glue(
    "\\mybox{{0.25\\textwidth}}{{{first_col[i]}}} & ",
    "\\mybox{{0.7\\textwidth}}{{{coinc[i]}}}"
  )
  
}) |> 
  stringr::str_flatten(" \\\\\n\\addlinespace\n")

cat("\\begin{longtable*}{ll}\n")
cat(coincides)
cat("\\end{longtable*}\n")
```

### Tags properly contained in the intersection of parent identifiers

```{r contained}
#| echo: false
#| warning: false
#| message: false
#| results: asis
first_col <- names(contained)
cont <- contained |> 
  sapply(\(x) {v <- x |> as_vector(); names(v)[v > 0] |> stringr::str_flatten(" $\\cap$ ")})
cont <- sapply(seq_along(contained), \(i) {
  
  glue::glue(
    "\\mybox{{0.25\\textwidth}}{{{first_col[i]}}} & ",
    "\\mybox{{0.7\\textwidth}}{{{cont[i]}}}"
  )
  
}) |> 
  stringr::str_flatten(" \\\\\n\\addlinespace\n")

cat("\\begin{longtable*}{ll}\n")
cat(cont)
cat("\\end{longtable*}\n")
```
